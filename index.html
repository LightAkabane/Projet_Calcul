<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebGPU Crowdly</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;600;700&family=Pacifico&display=swap" rel="stylesheet">

  <!-- ONNX Runtime Web (inclut support WebGPU si dispo) -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

<style>
    :root {
      --bg-1: #0f1020;
      --bg-2: #15162e;
      --accent: #a78bfa; /* lilac */
      --accent-2: #34d399; /* mint */
      --text: #e7e7ff;
      --muted: #a1a1b3;
      --card: rgba(255,255,255,0.06);
      --glass: rgba(255,255,255,0.08);
      --shadow: 0 10px 25px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.06);
    }

    * { box-sizing: border-box; }
    html {
  min-height: 100%;
  background: radial-gradient(1200px 700px at 10% 10%, #201a36 0%, transparent 55%),
              radial-gradient(1200px 700px at 90% 30%, #1a263d 0%, transparent 55%),
              linear-gradient(160deg, #0f1020, #15162e);
  background-attachment: fixed;
}

    body {
  margin: 0;
  min-height: 100vh;
  font-family: 'DM Sans', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  color: var(--text);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 20px 16px 80px;
  gap: 18px;
  overflow-x: hidden;
  background: transparent;
  position: relative;
}

    /* Subtle animated grain for lofi vibes */
    body::before {
      content: "";
      position: fixed; inset: 0;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="120" height="120" viewBox="0 0 120 120"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="2" stitchTiles="stitch"/></filter><rect width="120" height="120" filter="url(%23n)" opacity="0.05"/></svg>');
      mix-blend-mode: soft-light;
      pointer-events: none;
      animation: grain 6s steps(6) infinite;
    }
    @keyframes grain { to { transform: translate3d(-10px, 6px, 0); } }

    header {
      display: flex; align-items: center; gap: 14px;
    }
    .title {
      font-family: 'Pacifico', cursive;
      font-size: clamp(28px, 4vw, 42px);
      letter-spacing: 0.5px;
      color: var(--text);
      text-shadow: 0 2px 10px rgba(167, 139, 250, 0.25);
    }
    .badge {
      padding: 6px 10px; border-radius: 999px; font-size: 12px; font-weight: 600; color: #0a0a12;
      background: linear-gradient(135deg, var(--accent), #7dd3fc);
      box-shadow: var(--shadow);
    }

    .deck {
      width: min(620px, 100%);
      display: grid; grid-template-columns: 1fr; gap: 16px;
      margin: auto;
    }

    .card {
      position: relative;
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px) saturate(115%);
      -webkit-backdrop-filter: blur(10px) saturate(115%);
    }

    /* Player / controls */
    .controls {
      display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 12px 14px 6px;
    }
    .controls-left { display: flex; align-items: center; gap: 10px; }
    .vinyl {
      width: 38px; height: 38px; border-radius: 999px; position: relative; flex: 0 0 auto;
      background:
        radial-gradient(circle at center, #0b0b14 0 28%, transparent 29%),
        radial-gradient(circle at center, #1c1c2b 0 52%, transparent 53%),
        conic-gradient(from 0deg, rgba(255,255,255,0.12) 0 10%, transparent 10% 20%, rgba(255,255,255,0.12) 20% 30%, transparent 30% 40%, rgba(255,255,255,0.12) 40% 50%, transparent 50% 60%, rgba(255,255,255,0.12) 60% 70%, transparent 70% 80%, rgba(255,255,255,0.12) 80% 90%, transparent 90% 100%);
      border: 2px solid rgba(255,255,255,0.08);
      display: grid; place-items: center;
      box-shadow: inset 0 0 0 2px rgba(0,0,0,0.35);
    }
    .vinyl::after {
      content: ""; width: 6px; height: 6px; border-radius: 999px; background: var(--accent-2);
      box-shadow: 0 0 10px var(--accent-2), 0 0 22px rgba(52,211,153,0.4);
    }
    .spin { animation: spin 6s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .btn {
      appearance: none; -webkit-tap-highlight-color: transparent;
      padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.12);
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
      color: var(--text); font-weight: 600; font-size: 14px;
      display: inline-flex; align-items: center; gap: 8px;
      cursor: pointer; transition: transform .08s ease, box-shadow .2s ease, background .2s ease;
      box-shadow: var(--shadow);
    }
    .btn:hover { transform: translateY(-2px); }
    .btn:active { transform: translateY(0); }

    .btn-primary { border-color: rgba(167,139,250,0.35); box-shadow: 0 0 0 0 rgba(167,139,250,0.6); }
    .btn-primary:hover { box-shadow: 0 8px 24px rgba(167,139,250,0.25); }

    .pill {
      padding: 6px 10px; border-radius: 999px; font-weight: 700; font-size: 12px; letter-spacing: .3px;
      color: #0a0a12; background: linear-gradient(135deg, #22d3ee, #a78bfa);
    }

    /* Main visual area */
    .stage { padding: 14px; }
    #container {
      position: relative; width: 100%; aspect-ratio: 4 / 3; border-radius: 16px; overflow: hidden;
      border: 1px solid rgba(255,255,255,0.12);
      background: #05060a;
    }
    video, canvas { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; }

    /* Neon corner glow */
    #container::before {
      content: ""; position: absolute; right: -80px; top: -80px; width: 220px; height: 220px; border-radius: 50%;
      background: radial-gradient(closest-side, rgba(167,139,250,0.35), transparent 70%);
      filter: blur(12px); pointer-events: none;
    }

    /* Status & counters */
    .hud { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding: 0 14px 14px; }
    #status { color: var(--muted); font-size: 14px; }
    #counter, #unique-counter {
      font-weight: 700; font-size: 15px; padding: 10px 12px; border-radius: 12px;
      background: var(--card); border: 1px solid rgba(255,255,255,0.08);
      display: inline-flex; align-items: center; gap: 8px;
      box-shadow: var(--shadow);
    }
    #counter { color: #34d399; }
    #unique-counter { color: #60a5fa; }

    footer { color: var(--muted); font-size: 12px; opacity: .9; }

    /* Floating musical notes for extra chill */
    .notes { position: fixed; left: 8px; bottom: 8px; pointer-events: none; opacity: .25; font-size: 18px; }
    .note { position: absolute; animation: rise 8s linear infinite; }
    .note:nth-child(2) { left: 18px; animation-delay: 1.2s; }
    .note:nth-child(3) { left: 36px; animation-delay: 2.4s; }
    .note:nth-child(4) { left: 54px; animation-delay: 3.6s; }
    .note:nth-child(5) { left: 72px; animation-delay: 4.8s; }
    @keyframes rise {
      0% { transform: translateY(0) rotate(0deg); opacity: .15; }
      50% { opacity: .35; }
      100% { transform: translateY(-120px) rotate(20deg); opacity: 0; }
    }

    /* Responsive tweaks */
    @media (max-width: 720px) {
      .hud { grid-template-columns: 1fr; }
      .controls { flex-wrap: wrap; }
    }

    /* === Mise en page 3 colonnes : image gauche ¬∑ deck ¬∑ image droite === */
.layout {
  display: grid;
  grid-template-columns: 1fr minmax(0, 1100px) 1fr;
  align-items: start;
  gap: 24px;
  margin:auto
}

/* Cartes images lat√©rales */
.side {
  background: var(--glass);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 18px;
  box-shadow: var(--shadow);
  overflow: hidden;
  /* Augment√©e : 4/5 au lieu de 3/4 */
  aspect-ratio: 4 / 5;
  /* Pour qu'elle reste visible au scroll (si la page est longue) */
  position: sticky;
  top: 16px;
  max-height: calc(100vh - 32px - 48px); /* marges header/padding */
  display: grid;
  place-items: center;
}

/* L'image √† l'int√©rieur */
.side > img {
  width: 100%;
  height: 100%;
  object-fit: cover;   /* cover = rempli le cadre, crop √©l√©gant */
  display: block;
}

/* Sur mobile/tablette : on cache les c√¥t√©s pour garder la place au deck */
@media (max-width: 1024px) {
  .layout { grid-template-columns: 1fr; gap: 16px; }
  .side { display: none; }
  .deck { width: min(420px, 100%); }
}

  </style>
</head>

<body>
  <header>
    <div class="badge">WebGPU</div>
    <h1 class="title">Crowdly</h1>
  </header>

  <div class="layout">
  <aside class="side">
    <img src="200w.gif" alt="Affiche lofi c√¥t√© gauche">
  </aside>

  <section class="deck">
    <div class="card">
      <div class="controls">
        <div class="controls-left">
          <div id="vinyl" class="vinyl" title="Ambiance lofi"></div>
          <button id="btnPlay" class="btn btn-primary" type="button">‚ñ∂Ô∏é Play lofi</button>
          <button id="btnMute" class="btn" type="button">üîá Mute</button>

        </div>
        <div style="display:flex;gap:10px;align-items:center">
          <label style="font-size:12px;color:var(--muted);">Confiance</label>
          <input id="thresh" type="range" min="0.2" max="0.95" step="0.01" value="0.60"/>
          <span id="threshVal" style="font-size:12px;color:var(--text);font-weight:700;min-width:36px;text-align:right">0.60</span>
        </div>
      </div>
      <div class="stage">
        <div id="container">
          <video id="video" autoplay playsinline></video>
          <canvas id="overlay"></canvas>
        </div>
      </div>
      <div class="hud">
        <div id="status">Initialisation...</div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end">
          <div id="counter">üëÄ Personnes d√©tect√©es : 0</div>
          <div id="unique-counter">üåü Personnes uniques vues : 0</div>
        </div>
      </div>
    </div>
  </section>

  <aside class="side">
    <img src="200w2.gif" alt="Affiche lofi c√¥t√© droit">
  </aside>
</div>

  <!-- Ambient audio (remplace src par ton propre flux lofi si tu veux) -->
  <audio id="lofiAudio" loop crossorigin="anonymous">
    <!-- Exemple libre: https://cdn.pixabay.com/download/audio/2022/03/15/audio_2f0b319e5e.mp3?filename=lofi-study-112191.mp3 -->
    <source src="song.mp3" type="audio/mpeg" />
  </audio>

  <div class="notes" aria-hidden="true">
    <div class="note">‚ô™</div>
    <div class="note">‚ô¨</div>
    <div class="note">‚ú¶</div>
    <div class="note">‚ô©</div>
    <div class="note">‚òæ</div>
  </div>

<script>
  // ========
  // EXISTANT : d√©tection + Re-ID (l√©g√®rement factoris√© pour supporter le slider de confiance)
  // ========

  const video = document.getElementById('video');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');
  const counterEl = document.getElementById('counter');
  const uniqueCounterEl = document.getElementById('unique-counter');

  const vinyl = document.getElementById('vinyl');
  const btnPlay = document.getElementById('btnPlay');
  const btnMute = document.getElementById('btnMute');
  const audio = document.getElementById('lofiAudio');
  const threshEl = document.getElementById('thresh');
  const threshVal = document.getElementById('threshVal');

  // Tracking (court terme)
  let tracks = [];
  let nextTrackId = 1;

  // Galerie d'identit√©s Re-ID (long terme)
  let identities = [];
  let nextIdentityId = 1;

  const MAX_MISSED_FRAMES = 20;
  const MIN_HITS = 5;

  // Taille d'entr√©e du mod√®le YOLO
  const MODEL_WIDTH = 640;
  const MODEL_HEIGHT = 640;

  const offscreenCanvas = document.createElement('canvas');
  offscreenCanvas.width = MODEL_WIDTH;
  offscreenCanvas.height = MODEL_HEIGHT;
  const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });

  // OSNet Re-ID
  const REID_HEIGHT = 256;
  const REID_WIDTH = 128;

  const reidCanvas = document.createElement('canvas');
  reidCanvas.width = REID_WIDTH;
  reidCanvas.height = REID_HEIGHT;
  const reidCtx = reidCanvas.getContext('2d', { willReadFrequently: true });

  // Sessions ONNX
  let session = null;
  let inputName = null;

  let reidSession = null;
  let reidInputName = null;
  let reidOutputName = null;

  // Seuil de confiance dynamique (li√© au slider UI)
  let CONF_THRESHOLD = parseFloat(threshEl.value);

  threshEl.addEventListener('input', () => {
    CONF_THRESHOLD = parseFloat(threshEl.value);
    threshVal.textContent = CONF_THRESHOLD.toFixed(2);
  });

  // ---- Ambiance audio
  const setPlayingUI = (playing) => {
    vinyl.classList.toggle('spin', playing);
    btnPlay.textContent = playing ? '‚è∏Ô∏é Pause lofi' : '‚ñ∂Ô∏é Play lofi';
  };

  btnPlay.addEventListener('click', async () => {
    try {
      if (audio.paused) { await audio.play(); setPlayingUI(true); }
      else { audio.pause(); setPlayingUI(false); }
    } catch (e) {
      console.warn('Lecture audio bloqu√©e par le navigateur (interaction requise)');
    }
  });

  btnMute.addEventListener('click', () => {
    audio.muted = !audio.muted;
    btnMute.textContent = audio.muted ? 'üîä Unmute' : 'üîá Mute';
  });

  async function initCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
      video.srcObject = stream;
      return new Promise((resolve) => {
        video.onloadedmetadata = () => {
          video.play();
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          resolve();
        };
      });
    } catch (err) {
      console.error(err);
      statusEl.textContent = 'Erreur acc√®s cam√©ra : ' + err.message;
    }
  }

  async function initOrt() {
    if (!('gpu' in navigator)) {
      statusEl.textContent = 'WebGPU non disponible (Chrome/Edge r√©cent n√©cessaire).';
      throw new Error('WebGPU not supported');
    }

    statusEl.textContent = 'Initialisation des mod√®les (YOLO + OSNet Re-ID)...';

    try {
      session = await ort.InferenceSession.create('yolov8n.onnx', {
        executionProviders: ['webgpu', 'wasm']
      });
      inputName = session.inputNames[0];
      console.log('Session YOLO initialis√©e, input =', inputName);
    } catch (e) {
      console.error('Erreur init YOLO:', e);
      throw e;
    }

    try {
      reidSession = await ort.InferenceSession.create('osnet_reid.onnx', { executionProviders: ['wasm'] });
      reidInputName = reidSession.inputNames[0];
      reidOutputName = reidSession.outputNames[0];
      console.log('Session OSNet Re-ID initialis√©e, input =', reidInputName, 'output =', reidOutputName);
    } catch (e) {
      console.error('Erreur init OSNet Re-ID:', e);
      statusEl.textContent = 'YOLO OK, mais OSNet Re-ID non initialis√© (voir console).';
      reidSession = null;
    }
  }

  function cosineSimilarity(a, b) {
    let dot = 0, na = 0, nb = 0;
    for (let i = 0; i < a.length; i++) { const va = a[i], vb = b[i]; dot += va*vb; na += va*va; nb += vb*vb; }
    if (na === 0 || nb === 0) return 0; return dot / (Math.sqrt(na) * Math.sqrt(nb));
  }

  function assignIdentityToTrack(track) {
    if (!track.embedding) return;
    const IDENTITY_THRESHOLD = 0.7;
    let bestIdentity = null, bestSim = -1;
    for (const ident of identities) {
      const sim = cosineSimilarity(track.embedding, ident.embedding);
      if (sim > bestSim) { bestSim = sim; bestIdentity = ident; }
    }
    if (bestIdentity && bestSim >= IDENTITY_THRESHOLD) {
      track.identityId = bestIdentity.id;
      const emb = bestIdentity.embedding; const newEmb = track.embedding; // EMA
      for (let i = 0; i < emb.length; i++) { emb[i] = 0.7 * newEmb[i] + 0.3 * emb[i]; }
    } else {
      const id = nextIdentityId++;
      track.identityId = id;
      identities.push({ id, embedding: track.embedding.slice() });
    }
  }

  function preprocessReid(det) {
    reidCtx.clearRect(0, 0, REID_WIDTH, REID_HEIGHT);
    reidCtx.drawImage(video, det.x, det.y, det.w, det.h, 0, 0, REID_WIDTH, REID_HEIGHT);
    const imageData = reidCtx.getImageData(0, 0, REID_WIDTH, REID_HEIGHT);
    const data = imageData.data;
    const float32Data = new Float32Array(3 * REID_WIDTH * REID_HEIGHT);
    const size = REID_WIDTH * REID_HEIGHT;
    const mean = [0.485, 0.456, 0.406];
    const std  = [0.229, 0.224, 0.225];
    for (let i = 0; i < size; i++) {
      const r = data[4*i] / 255, g = data[4*i+1] / 255, b = data[4*i+2] / 255;
      float32Data[i] = (r - mean[0]) / std[0];
      float32Data[i+size] = (g - mean[1]) / std[1];
      float32Data[i+2*size] = (b - mean[2]) / std[2];
    }
    return new ort.Tensor('float32', float32Data, [1, 3, REID_HEIGHT, REID_WIDTH]);
  }

  async function extractReidEmbedding(det) {
    if (!reidSession) return null;
    try {
      const inputTensor = preprocessReid(det);
      const feeds = {}; feeds[reidInputName] = inputTensor;
      const results = await reidSession.run(feeds);
      const output = results[reidOutputName];
      const embedding = output.data; // Float32Array
      let norm = 0; for (let i = 0; i < embedding.length; i++) norm += embedding[i]*embedding[i];
      norm = Math.sqrt(norm) || 1;
      const normalized = new Float32Array(embedding.length);
      for (let i = 0; i < embedding.length; i++) normalized[i] = embedding[i]/norm;
      return normalized;
    } catch (e) { console.error('Erreur OSNet Re-ID sur une d√©tection:', e); return null; }
  }

  function preprocess() {
    offscreenCtx.drawImage(video, 0, 0, MODEL_WIDTH, MODEL_HEIGHT);
    const imageData = offscreenCtx.getImageData(0, 0, MODEL_WIDTH, MODEL_HEIGHT);
    const { data } = imageData;
    const float32Data = new Float32Array(3 * MODEL_WIDTH * MODEL_HEIGHT);
    const size = MODEL_WIDTH * MODEL_HEIGHT;
    for (let i = 0; i < size; i++) {
      const r = data[4*i] / 255, g = data[4*i+1] / 255, b = data[4*i+2] / 255;
      float32Data[i] = r; float32Data[i+size] = g; float32Data[i+2*size] = b;
    }
    const tensor = new ort.Tensor('float32', float32Data, [1, 3, MODEL_HEIGHT, MODEL_WIDTH]);
    return tensor;
  }

  function iou(boxA, boxB) {
    const xA = Math.max(boxA.x1, boxB.x1), yA = Math.max(boxA.y1, boxB.y1);
    const xB = Math.min(boxA.x2, boxB.x2), yB = Math.min(boxA.y2, boxB.y2);
    const interW = Math.max(0, xB - xA), interH = Math.max(0, yB - yA);
    const interArea = interW * interH;
    const boxAArea = (boxA.x2 - boxA.x1) * (boxA.y2 - boxA.y1);
    const boxBArea = (boxB.x2 - boxB.x1) * (boxB.y2 - boxB.y1);
    const union = boxAArea + boxBArea - interArea; if (union <= 0) return 0; return interArea / union;
  }

  function nonMaxSuppression(boxes, iouThreshold = 0.45) {
    const sorted = boxes.slice().sort((a, b) => b.score - a.score);
    const result = [];
    while (sorted.length > 0) {
      const candidate = sorted.shift();
      result.push(candidate);
      for (let i = sorted.length - 1; i >= 0; i--) {
        if (iou(candidate, sorted[i]) > iouThreshold) sorted.splice(i, 1);
      }
    }
    return result;
  }

  function updateTracks(detections) {
    tracks.forEach(t => { t.matched = false; });
    const IOU_MATCH_THRESHOLD = 0.3;
    detections.forEach(det => {
      const detBox = { x1: det.x, y1: det.y, x2: det.x + det.w, y2: det.y + det.h };
      let bestTrack = null, bestIoU = 0;
      tracks.forEach(track => {
        const trackBox = { x1: track.x, y1: track.y, x2: track.x + track.w, y2: track.y + track.h };
        const iouVal = iou(detBox, trackBox);
        if (iouVal > bestIoU) { bestIoU = iouVal; bestTrack = track; }
      });
      if (bestTrack && bestIoU > IOU_MATCH_THRESHOLD) {
        const alpha = 0.7; // EMA
        bestTrack.x = alpha * det.x + (1 - alpha) * bestTrack.x;
        bestTrack.y = alpha * det.y + (1 - alpha) * bestTrack.y;
        bestTrack.w = alpha * det.w + (1 - alpha) * bestTrack.w;
        bestTrack.h = alpha * det.h + (1 - alpha) * bestTrack.h;
        if (det.embedding) bestTrack.embedding = det.embedding.slice();
        bestTrack.missed = 0; bestTrack.hits = (bestTrack.hits || 0) + 1; bestTrack.matched = true;
        if (!bestTrack.confirmed && bestTrack.hits >= MIN_HITS) { bestTrack.confirmed = true; assignIdentityToTrack(bestTrack); }
        det.id = bestTrack.confirmed ? bestTrack.id : null;
      } else {
        const newTrack = { id: nextTrackId++, x: det.x, y: det.y, w: det.w, h: det.h, missed: 0, hits: 1, confirmed: false, matched: true, embedding: det.embedding ? det.embedding.slice() : null, identityId: null };
        tracks.push(newTrack);
        det.id = null;
      }
    });

    tracks = tracks.filter(track => { if (!track.matched) track.missed = (track.missed || 0) + 1; return track.missed <= MAX_MISSED_FRAMES; });
    return detections;
  }

  function postprocess(output) {
    const data = output.data; const dims = output.dims;
    const channels = dims[1]; const numAnchors = dims[2];
    const numClasses = channels - 4; const boxes = [];

    for (let i = 0; i < numAnchors; i++) {
      const cx = data[0 * numAnchors + i];
      const cy = data[1 * numAnchors + i];
      const w  = data[2 * numAnchors + i];
      const h  = data[3 * numAnchors + i];
      if (w <= 0 || h <= 0) continue;
      let bestScore = -Infinity, bestClass = -1;
      for (let c = 0; c < numClasses; c++) {
        const score = data[(4 + c) * numAnchors + i];
        if (score > bestScore) { bestScore = score; bestClass = c; }
      }
      const prob = bestScore;
      if (bestClass !== 0 || prob < CONF_THRESHOLD) continue; // <<< seuil dynamique
      let x1 = (cx - w/2) / MODEL_WIDTH, y1 = (cy - h/2) / MODEL_HEIGHT, x2 = (cx + w/2) / MODEL_WIDTH, y2 = (cy + h/2) / MODEL_HEIGHT;
      if (x2 <= x1 || y2 <= y1) continue; if (x2 < 0 || y2 < 0 || x1 > 1 || y1 > 1) continue;
      x1 = Math.max(0, Math.min(1, x1)); y1 = Math.max(0, Math.min(1, y1)); x2 = Math.max(0, Math.min(1, x2)); y2 = Math.max(0, Math.min(1, y2));
      boxes.push({ x1, y1, x2, y2, score: prob, classId: bestClass });
    }

    const nmsBoxes = nonMaxSuppression(boxes, 0.45);
    return nmsBoxes.map(b => ({ x: b.x1 * canvas.width, y: b.y1 * canvas.height, w: (b.x2 - b.x1) * canvas.width, h: (b.y2 - b.y1) * canvas.height, score: b.score }));
  }

  function drawDetections(detections) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 2; ctx.font = '600 14px DM Sans, system-ui';
    detections.forEach(det => {
      ctx.strokeStyle = '#34d399';
      ctx.fillStyle = '#a78bfa';
      ctx.shadowColor = 'rgba(167,139,250,0.45)';
      ctx.shadowBlur = 12;
      ctx.strokeRect(det.x, det.y, det.w, det.h);
      const label = `Person ${(det.score * 100).toFixed(1)}%`;
      const textX = det.x + 6; const textY = Math.max(16, det.y - 8);
      ctx.fillText(label, textX, textY);
      ctx.shadowBlur = 0;
    });
  }

  async function runDetectionOnce() {
    if (!session) return;
    const inputTensor = preprocess();
    const feeds = {}; feeds[inputName] = inputTensor;
    const results = await session.run(feeds);
    const outputName = session.outputNames[0];
    const output = results[outputName];
    let detections = postprocess(output);
    if (reidSession) {
      for (const det of detections) { det.embedding = await extractReidEmbedding(det); }
    } else { for (const det of detections) det.embedding = null; }
    detections = updateTracks(detections);
    const activeDetections = detections.filter(det => det.id != null);
    if (counterEl) counterEl.textContent = `üëÄ Personnes d√©tect√©es : ${activeDetections.length}`;
    if (uniqueCounterEl) uniqueCounterEl.textContent = `üåü Personnes uniques vues : ${identities.length}`;
    drawDetections(activeDetections);
  }

  let isRunning = false;
  async function detectionLoop() {
    if (!isRunning) return;
    await runDetectionOnce();
    requestAnimationFrame(detectionLoop);
  }

  (async () => {
    try {
      statusEl.textContent = 'Demande d\'acc√®s √† la cam√©ra...';
      await initCamera();
      statusEl.textContent = 'Cam√©ra OK. Initialisation WebGPU / mod√®les...';
      await initOrt();
      statusEl.textContent = 'Mod√®les charg√©s, d√©tection en cours...';
      isRunning = true; detectionLoop();
    } catch (err) {
      console.error(err);
      statusEl.textContent = 'Erreur initialisation : ' + err.message;
    }
  })();
</script>
</body>
</html>
